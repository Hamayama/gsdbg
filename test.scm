;;;
;;; Test gsdbg
;;;

(add-load-path "." :relative)
;(import (scheme base)
;        (gauche base)
;        (gauche interactive)
;        (gsdbg))
(use gauche.interactive)
(use gsdbg)

(define *x* 1000)
(define *y* '(1 2 3 4 5))

(define (proc1)
  (define x 2000)
  (define y '(6 7 8 9 10))
  (print "Please type \",c\" to exit debugger")
  (print "(Type \",h\" for command help.)")
  (print "===== proc1 (global) start =====")
  (print "*x*=" *x*)
  (print "*y*=" *y*)
  ;(read-eval-print-loop)
  ;(print "ret=" (gsdbg "proc1-A" `((x ,x) (y ,y))))
  (gsdbg "proc1-A" `((x ,x) (y ,y)))
  (set! *x* 1001)
  (set! *y* '(2 3 4 5 6))
  (print "*x*=" *x*)
  (print "*y*=" *y*)
  (gsdbg "proc1-B" `((x ,x) (y ,y)))
  (print "===== proc1 (global) end ====="))

(define-module test-mod
  (use gsdbg)
  (export proc2)
  (define *u* 10000)
  (define *v* '(10 20 30 40 50))
  (define (proc2)
    (define u 20000)
    (define v '(60 70 80 90 100))
    (print "===== proc2 (in test-mod) start =====")
    (print "*u*=" *u*)
    (print "*v*=" *v*)
    (print "If you want to display *u* in debugger,")
    (print "please type \",sm test-mod\" .")
    ;(read-eval-print-loop)
    (gsdbg "proc2-A" `((u ,u) (v ,v)))
    (set! *u* 10001)
    (set! *v* '(11 12 13 14 15))
    (print "*u*=" *u*)
    (print "*v*=" *v*)
    (gsdbg "proc2-B" `((u ,u) (v ,v)))
    (print "===== proc2 (in test-mod) end ====="))
  )
;(import (test-mod))
(import test-mod)

(proc1)
(newline)
(proc2)

