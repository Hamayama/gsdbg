;;;
;;; Test gsdbg
;;;

(add-load-path "." :relative)
;(import (scheme base)
;        (gauche base)
;        (gauche interactive)
;        (gsdbg))
(use gauche.interactive)
(use gsdbg)

(define *x* 1000)
(define *y* '(1 2 3 4 5))

(define (proc1)
  (define x 2000)
  (define y '(6 7 8 9 10))
  (define z "12345")
  (print "Please type \",c\" to exit debugger")
  (print "(Type \",h\" for command help.)")
  (print "===== proc1 (global) start =====")
  (format #t "*x*=~s\n" *x*)
  (format #t "*y*=~s\n" *y*)
  ;(read-eval-print-loop)
  (gsdbg "proc1-A" `((x ,x) (y ,y) (z ,z)))
  (format #t "*x*=~s\n" *x*)
  (format #t "*y*=~s\n" *y*)
  (format #t "ret=~s\n" (gsdbg "proc1-B" `((x ,x) (y ,y) (z ,z))))
  (print "===== proc1 (global) end ====="))

(define-module test-mod
  (use gsdbg)
  (export proc2)
  (define *u* 10000)
  (define *v* '(10 20 30 40 50))
  (define (proc2)
    (define u 20000)
    (define v '(60 70 80 90 100))
    (define w "ABCDE")
    (print "===== proc2 (in test-mod) start =====")
    (format #t "*u*=~s\n" *u*)
    (format #t "*v*=~s\n" *v*)
    (print "If you want to display *u* in debugger,")
    (print "please type \",sm test-mod\" .")
    ;(read-eval-print-loop)
    (gsdbg "proc2-A" `((u ,u) (v ,v) (w ,w)))
    (format #t "*u*=~s\n" *u*)
    (format #t "*v*=~s\n" *v*)
    (format #t "ret=~s\n" (gsdbg "proc2-B" `((u ,u) (v ,v) (w ,w))))
    (print "===== proc2 (in test-mod) end ====="))
  )
;(import (test-mod))
(import test-mod)

(proc1)
(newline)
(proc2)

